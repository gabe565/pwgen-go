package main

import (
	"bufio"
	"bytes"
	"errors"
	"fmt"
	"net/http"
	"strings"

	. "github.com/dave/jennifer/jen" //nolint:revive,stylecheck
)

type config struct {
	url         string
	name        string
	description string
}

func main() {
	configs := []config{
		{
			"https://www.eff.org/files/2016/07/18/eff_large_wordlist.txt",
			"EFF_Long",
			"is the default wordlist used for passphrases.\nIt contains 7776 words and is designed for memorability and password strength.",
		},
		{
			"https://eff.org/files/2016/09/08/eff_short_wordlist_1.txt",
			"EFF_Short1",
			"features only short words.\nIt contains 1296 words and may be more efficient to type, but suggests using more words to maintain security.",
		},
		{
			"https://eff.org/files/2016/09/08/eff_short_wordlist_2_0.txt",
			"EFF_Short2",
			"features longer words and may be more memorable.\nIt contains 1296 words and may be more efficient to type, but suggests using more words to maintain security.",
		},
	}

	for _, conf := range configs {
		if err := templateFile(conf); err != nil {
			panic(err)
		}
	}
}

var (
	errStatusCode = errors.New("invalid response")
	errNoWords    = errors.New("list did not contain any words")
)

func templateFile(conf config) error {
	//nolint:noctx
	resp, err := http.Get(conf.url)
	if err != nil {
		return err
	}
	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("%w: %s", errStatusCode, resp.Status)
	}

	f := NewFile("wordlist")
	f.HeaderComment("// Code generated by internal/wordlist/generate; DO NOT EDIT.")

	f.Comment(conf.name + " " + conf.description + "\n\n" + "Source: https://www.eff.org/dice")
	scanner := bufio.NewScanner(resp.Body)
	var count int
	f.Func().Id(conf.name).Params().Id("Wordlist").Block(
		Return(
			Id("Wordlist").BlockFunc(func(group *Group) {
				for scanner.Scan() {
					word := scanner.Bytes()
					// Remove comments
					if word, _, _ = bytes.Cut(word, []byte("#")); len(word) != 0 {
						// Remove number prefix
						if _, word, _ = bytes.Cut(word, []byte("\t")); len(word) != 0 {
							count++
							group.Lit(string(word)).Op(",")
						}
					}
				}
			}),
		),
	)
	if scanner.Err() != nil {
		return err
	}
	if count == 0 {
		return errNoWords
	}

	if err := resp.Body.Close(); err != nil {
		return err
	}

	return f.Save(strings.ToLower(conf.name) + ".go")
}
